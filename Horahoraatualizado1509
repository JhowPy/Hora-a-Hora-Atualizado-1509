# -*- coding: utf-8 -*-
# ========= IMPORTS =========
import os
import time
import shutil
import tempfile
import pandas as pd
import xlwings as xw
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter
from datetime import datetime, time as dt_time
from xlwings.constants import HAlign
from uuid import uuid4

# ========= FECHA QUALQUER EXCEL ABERTO =========
os.system("taskkill /f /im excel.exe 2>nul")

# ========= DATA E ARQUIVOS =========
# Ajuste aqui a data que você quer calcular/filtrar
data_manual = datetime(2025, 9, 15)
dia_especifico = data_manual.date()

# Pasta base
base_dir = r"F:\BACKOFFICE - CONTACT CENTER\Relatorios Extraidos Automacao"

# Você define o nome do arquivo de entrada aqui (ex.: "1308.xlsx" ou "13.08.xlsx")
nome_arquivo = "1609.xlsx"

# Caminhos
caminho_arquivo_original = fr"{base_dir}\{nome_arquivo}"
nome_sem_ext = os.path.splitext(nome_arquivo)[0]
caminho_formatado = fr"{base_dir}\{nome_sem_ext}_Formatado.xlsx"
caminho_dashboard = fr"{base_dir}\Dashboard.xlsx"  # confirmado
caminho_backup = fr"{base_dir}\Dashboard_Template.xlsx"

# ========= BACKUP DO DASHBOARD =========
if os.path.exists(caminho_dashboard):
    shutil.copy(caminho_dashboard, caminho_backup)

# ========= FORMATAR PLANILHA BASE =========
if not os.path.exists(caminho_arquivo_original):
    raise FileNotFoundError(f"Arquivo não encontrado: {caminho_arquivo_original}")

# Salva a planilha original como "Base de Dados"
pd.read_excel(caminho_arquivo_original, dtype=str).to_excel(
    caminho_formatado, index=False, sheet_name="Base de Dados"
)

# Insere "Nova Coluna" com hora extraída de "Hr. Associação Comercial"
wb_aux = load_workbook(caminho_formatado)
ws_aux = wb_aux["Base de Dados"]
df_temp = pd.read_excel(caminho_formatado, sheet_name="Base de Dados", dtype=str)

coluna_Hr_Associacao = "Hr. Associação Comercial"
coluna_Tempo_Associacao = "Tempo de Associação"
coluna_Hr_idx = df_temp.columns.get_loc(coluna_Hr_Associacao) + 1
coluna_Tempo_idx = df_temp.columns.get_loc(coluna_Tempo_Associacao) + 1

ws_aux.insert_cols(coluna_Tempo_idx)
ws_aux[f"{get_column_letter(coluna_Tempo_idx)}1"] = "Nova Coluna"

for row in range(2, ws_aux.max_row + 1):
    valor_hora = ws_aux.cell(row=row, column=coluna_Hr_idx).value
    try:
        hora = datetime.strptime(str(valor_hora).strip(), "%H:%M").hour
        ws_aux.cell(row=row, column=coluna_Tempo_idx).value = hora
    except (ValueError, TypeError):
        continue

wb_aux.save(caminho_formatado)

# ========= FUNÇÕES AUXILIARES =========
def tempo_personalizado(valor):
    """Converte 'HH:MM' ou 'HH:MM:SS' para timedelta; caso contrário, NaT."""
    try:
        partes = valor.strip().split(":")
        if len(partes) == 2:
            return pd.to_timedelta(f"{int(partes[0])}:{int(partes[1])}:00")
        elif len(partes) == 3:
            return pd.to_timedelta(valor)
        else:
            return pd.NaT
    except (ValueError, AttributeError):
        return pd.NaT

def classificar_q(c):
    try:
        p = float(c.replace('%', ''))
        if p >= 100:
            return "Q1"
        elif p >= 95:
            return "Q2"
        elif p >= 90:
            return "Q3"
        else:
            return "Q4"
    except:
        return "-"

def gerar_resumo_com_media(df_base, titulo):
    tabela = pd.pivot_table(
        df_base, index=["Período", "Usuário Backoffice"], columns="Hora",
        values="Nova Coluna", aggfunc="count", fill_value=0
    ).reset_index()

    tabela["Total"] = tabela.drop(columns=["Período", "Usuário Backoffice"]).sum(axis=1)
    medias = tabela.groupby("Período")["Total"].mean().to_dict()

    tabela["Conversão"] = tabela.apply(
        lambda row: f"{round((row['Total'] / medias.get(row['Período'], 1)) * 100):.0f}%"
        if medias.get(row['Período']) else "-",
        axis=1
    )
    tabela["Classificação"] = tabela["Conversão"].apply(classificar_q)

    colunas = tabela.columns.tolist()
    colunas.remove("Conversão")
    colunas.remove("Classificação")
    colunas += ["Conversão", "Classificação"]
    tabela = tabela[colunas]

    tabela.insert(0, "Dia", titulo)

    media_final = (
        tabela.groupby("Período").mean(numeric_only=True).round(1).reset_index().drop_duplicates(subset=["Período"])
    )
    media_final.insert(0, "Dia", f"Média - {titulo}")
    media_final["Usuário Backoffice"] = "-"
    media_final["Conversão"] = "-"
    media_final["Classificação"] = "-"
    media_final = media_final.groupby("Período").first().reset_index()

    linha_vazia = pd.DataFrame([["" for _ in tabela.columns]], columns=tabela.columns)
    return pd.concat([tabela, linha_vazia, media_final], ignore_index=True)

def hex_to_bgr(hex_color):
    """Converte '#RRGGBB' para inteiro BGR (Excel COM)."""
    hex_color = hex_color.lstrip('#')
    r = int(hex_color[0:2], 16)
    g = int(hex_color[2:4], 16)
    b = int(hex_color[4:6], 16)
    return r + (g << 8) + (b << 16)

def save_copy_of_wb(wb):
    r"""Gera uma cópia do workbook aberto (com as alterações) em um arquivo temporário (C:\Temp)."""
    tmp = os.path.join(tempfile.gettempdir(), f"_tmp_{uuid4().hex}.xlsx")
    wb.api.SaveCopyAs(tmp)
    return tmp

def atomic_replace_with_retries(src_tmp, dst_final, retries=30, delay=0.25):
    """
    Troca o arquivo final pelo temporário com tentativas e backoff.
    Evita WinError 17 (discos diferentes) copiando primeiro para um
    temporário no MESMO DIRETÓRIO do destino e então faz os.replace.
    """
    dst_dir = os.path.dirname(dst_final)
    tmp_local = os.path.join(dst_dir, f"._swap_{uuid4().hex}.xlsx")
    last_err = None

    for i in range(retries):
        try:
            # Copia para o mesmo drive/pasta do destino
            if os.path.exists(tmp_local):
                try:
                    os.remove(tmp_local)
                except:
                    pass
            shutil.copyfile(src_tmp, tmp_local)

            # Substitui de forma atômica no mesmo volume
            os.replace(tmp_local, dst_final)

            # Limpa o src_tmp (C:\Temp)
            try:
                if os.path.exists(src_tmp):
                    os.remove(src_tmp)
            except:
                pass

            return  # sucesso
        except (PermissionError, OSError) as e:
            last_err = e
            # tenta limpar tmp_local para próxima tentativa
            try:
                if os.path.exists(tmp_local):
                    os.remove(tmp_local)
            except:
                pass
            time.sleep(delay * (i + 1))  # backoff progressivo

    # esgotou tentativas
    raise last_err

def force_freeze_panes(ws, rows=1, cols=0, cell=None):
    """
    Congela 'rows' linhas e 'cols' colunas na planilha ws.
    Padrão: rows=1, cols=0 -> 1ª linha (A2). Para 1ª linha + 1ª coluna: rows=1, cols=1 (B2).
    """
    app = ws.book.app
    was_visible = app.visible
    app.visible = True  # garante janela ativa

    try:
        ws.api.Activate()
        win = app.api.ActiveWindow

        # Desprotege se necessário
        try:
            if bool(ws.api.ProtectContents):
                ws.api.Unprotect()
        except Exception:
            pass

        # Limpa estado e força Modo Normal
        win.View = 1
        win.FreezePanes = False
        win.SplitRow = 0
        win.SplitColumn = 0

        # Célula âncora
        if cell is None:
            r = 1 + max(rows, 0)
            c = 1 + max(cols, 0)
            cell = ws.range((r, c)).get_address(row_absolute=False, column_absolute=False)
        ws.api.Range(cell).Select()

        win.SplitRow = rows if rows > 0 else 0
        win.SplitColumn = cols if cols > 0 else 0
        win.FreezePanes = (rows > 0 or cols > 0)

    except Exception as e1:
        # Fallback usando a primeira janela do workbook
        try:
            wnd2 = ws.api.Parent.Windows(1)
            wnd2.View = 1
            wnd2.FreezePanes = False
            wnd2.SplitRow = 0
            wnd2.SplitColumn = 0
            ws.api.Range(cell).Select()
            wnd2.SplitRow = rows if rows > 0 else 0
            wnd2.SplitColumn = cols if cols > 0 else 0
            wnd2.FreezePanes = (rows > 0 or cols > 0)
        except Exception as e2:
            raise RuntimeError(f"Falha ao configurar FreezePanes: {e1} | fallback: {e2}")
    finally:
        app.visible = was_visible

# ========= LEITURA / TRATAMENTO DE DADOS =========
df = pd.read_excel(caminho_formatado, sheet_name="Base de Dados", dtype=str)

df["Dt. Associação Comercial"] = pd.to_datetime(df["Dt. Associação Comercial"], dayfirst=True, errors="coerce")
df["Hr. Associação Comercial"] = pd.to_datetime(
    df["Hr. Associação Comercial"], format="%H:%M", errors="coerce"
).dt.time
df["Dt. Pré-agendamento"] = pd.to_datetime(df["Dt. Pré-agendamento"], dayfirst=True, errors="coerce")
df["Hr. Pré-agendamento"] = pd.to_datetime(df["Hr. Pré-agendamento"], format="%H:%M", errors="coerce")
df["Nova Coluna"] = pd.to_numeric(df["Nova Coluna"], errors="coerce")
df["Tempo de Associação Convertido"] = df["Tempo de Associação"].apply(tempo_personalizado)
df["Dt. Visita Real"] = pd.to_datetime(df["Dt. Visita Real"], dayfirst=True, errors="coerce")
df["Hr. Visita"] = pd.to_datetime(df["Hr. Visita"], format="%H:%M", errors="coerce").dt.time

df = df.dropna(subset=[
    "Dt. Associação Comercial", "Nova Coluna", "Tempo de Associação Convertido",
    "Dt. Pré-agendamento", "Hr. Pré-agendamento"
])

df["Hora"] = df["Nova Coluna"].astype(int)
df["Data"] = df["Dt. Associação Comercial"].dt.date
df["Minutos Associacao"] = df["Tempo de Associação Convertido"].dt.total_seconds() / 60
df["Hora Pre"] = df["Hr. Pré-agendamento"].dt.hour

# ========= CÁLCULOS =========
horas = list(range(8, 19))
df_dia = df[df["Data"] == dia_especifico]
realizado = [df_dia[df_dia["Hora"] == h].shape[0] for h in horas]
menos_1h = [df_dia[(df_dia["Hora"] == h) & (df_dia["Minutos Associacao"] < 60)].shape[0] for h in horas]

df_real = df_dia[
    (df_dia["Dt. Pré-agendamento"].dt.date == dia_especifico) &
    (df_dia["Hr. Pré-agendamento"].dt.time >= dt_time(8, 0)) &
    (df_dia["Hr. Pré-agendamento"].dt.time <= dt_time(18, 30)) &
    (df_dia["Minutos Associacao"] >= 60)
]
perda_real = [df_real[df_real["Hora Pre"] == h].shape[0] for h in horas]

df_total = df_dia[
    (df_dia["Dt. Pré-agendamento"].dt.date == dia_especifico) &
    (df_dia["Hr. Pré-agendamento"].dt.time >= dt_time(6, 0)) &
    (df_dia["Hr. Pré-agendamento"].dt.time <= dt_time(23, 0)) &
    (df_dia["Minutos Associacao"] >= 60)
]

# Leads para 10h e acumulados
quantidade_10h = df[
    (df["Dt. Visita Real"].dt.date == dia_especifico) &
    (df["Hr. Visita"] >= dt_time(10, 0)) &
    (df["Hr. Visita"] < dt_time(11, 0)) &
    (df["Dt. Associação Comercial"].dt.date == dia_especifico)
].shape[0]

quantidade_0830 = df[
    (df["Dt. Pré-agendamento"].dt.date < dia_especifico) &
    (df["Dt. Associação Comercial"].dt.date == dia_especifico) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(8, 30))
].shape[0]

quantidade_acumulados = df[
    (df["Dt. Associação Comercial"].dt.date == dia_especifico) &
    (df["Dt. Pré-agendamento"].dt.date < dia_especifico)
].shape[0]

quantidade_mesmo_dia_0830 = df[
    (df["Dt. Associação Comercial"].dt.date == dia_especifico) &
    (df["Dt. Pré-agendamento"].dt.date == dia_especifico) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(8, 30))
].shape[0]

total_acumulado_completo = quantidade_acumulados + quantidade_mesmo_dia_0830

# ➕ Leads do mesmo dia com pré-agendamento até 07:30
total_acumulado_ate_0730 = df[
    (df["Dt. Associação Comercial"].dt.date == dia_especifico) &
    (df["Dt. Pré-agendamento"].dt.date == dia_especifico) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(7, 30))
].shape[0] + quantidade_acumulados

# ========= USUÁRIOS / PERÍODO =========
usuarios_desejados = [
    "CAROLINE APARECIDA DA SILVA BARROZO", "DAVI GUERRA VAINE SILVA", "DAYSE MIRANDA DOS SANTOS",
    "Diana Aparecida Barbosa Cesar", "DIANNE ALVES SILVA GONCALVES", "ISABELLY FERREIRA COSTA",
    "JOAO VICTOR GONCALVES TAVARES DA SILVA", "JULIA GOMES SILVA", "LARYSSA MIGORANÇA KLEIN DA SILVA",
    "MARIA DO ESPIRITO SANTO DA COSTA SILVA", "SARA ARAUJO SOUZA", "WESLLEY MORAES DE AMORIM",
    "RAFAELLA DIAS OLIVEIRA"
]
filtro_usuarios = df[df["Usuário Backoffice"].isin(usuarios_desejados)].copy()
filtro_usuarios["Período"] = filtro_usuarios["Usuário Backoffice"].apply(
    lambda x: "Manhã" if x in [

        "CAROLINE APARECIDA DA SILVA BARROZO", "DAYSE MIRANDA DOS SANTOS", "RAFAELLA DIAS OLIVEIRA",
        "Diana Aparecida Barbosa Cesar", "DIANNE ALVES SILVA GONCALVES", "ISABELLY FERREIRA COSTA",
        "JULIA GOMES SILVA", "MARIA DO ESPIRITO SANTO DA COSTA SILVA", "SARA ARAUJO SOUZA"


    ] else "Tarde"
)

# ========= EXCEL (SESSÃO ÚNICA) =========
app = xw.App(visible=False)
app.display_alerts = False
app.screen_updating = False

tmp_copy_path = None  # caminho da cópia do workbook

try:
    wb = app.books.open(caminho_dashboard, update_links=False, read_only=False)
    ws_base = wb.sheets["Base de Dados"]
    ws_performance = wb.sheets["Performance BackOffice"]

    # ---- Base de Dados ----
    for i, h in enumerate(horas):
        linha = i + 2
        ws_base[f"A{linha}"].value = f"{h:02d}:00"
        ws_base[f"B{linha}"].value = realizado[i]
        ws_base[f"C{linha}"].value = menos_1h[i]
        ws_base[f"D{linha}"].value = perda_real[i]

    ws_base["A15"].value = sum(menos_1h)
    ws_base["B15"].value = sum(realizado)
    ws_base["A18"].value = sum(perda_real)
    ws_base["B18"].value = df_total.shape[0]
    ws_base["B21"].value = quantidade_acumulados
    ws_base["B22"].value = total_acumulado_completo
    ws_base["B23"].value = total_acumulado_ate_0730

    ws_performance.range("R2").value = dia_especifico
    ws_performance.range("R2").number_format = "dd/mm/yyyy"
    ws_performance.range("M2").value = quantidade_10h
    ws_performance.range("M3").value = quantidade_0830
    ws_performance.range("L2").value = total_acumulado_completo

    # ---- Resumo por Hora ----
    resumo_sheet_name = data_manual.strftime("Resumo %d.%m")
    if resumo_sheet_name in [s.name for s in wb.sheets]:
        wb.sheets[resumo_sheet_name].delete()
    ws_resumo = wb.sheets.add(name=resumo_sheet_name, after=ws_performance)

    resumo = gerar_resumo_com_media(
        filtro_usuarios[filtro_usuarios["Data"] == dia_especifico],
        data_manual.strftime("%d/%m/%Y")
    )
    ws_resumo.range("A1").value = [resumo.columns.tolist()] + resumo.values.tolist()

    # Cabeçalho
    last_row = ws_resumo.range("A1").end("down").row
    last_col = ws_resumo.range("A1").end("right").column
    for col in range(1, last_col + 1):
        cell = ws_resumo.range((1, col))
        cell.color = "#002060"
        cell.font.color = "#FFFFFF"

    # Congelar 1ª linha (robusto)
    force_freeze_panes(ws_resumo, rows=1, cols=0)  # para 1ª linha+coluna: rows=1, cols=1

    # Largura da coluna "Usuário Backoffice"
    for col in range(1, last_col + 1):
        header_val = str(ws_resumo.range((1, col)).value).strip()
        if header_val == "Usuário Backoffice":
            ws_resumo.range((1, col)).column_width = 30
            break

    # Cores e formatação (parse % corrigido)
    for row in range(2, last_row + 1):
        valores_linha = [ws_resumo.range((row, col)).value for col in range(1, last_col + 1)]
        if all(v in [None, ""] for v in valores_linha):
            continue

        for col in range(1, last_col + 1):
            cell = ws_resumo.range((row, col))
            header = str(ws_resumo.range((1, col)).value).strip()

            if header == "Conversão":
                valor = cell.value
                if isinstance(valor, (int, float)):
                    valor = f"{valor:.0f}%"
                else:
                    valor = str(valor)
                try:
                    if valor.endswith("%"):
                        pct = float(valor.replace("%", "").replace(",", "."))
                        if pct >= 100:
                            cell.api.Interior.Color = 0x00FF00
                        elif pct >= 95:
                            cell.api.Interior.Color = 0xE2EFDA
                        elif pct >= 91:
                            cell.api.Interior.Color = 0xFFF2CC
                        else:
                            cell.api.Interior.Color = 0xF8CBAD
                except:
                    pass

            if header in ["Usuário Backoffice", "Total", "Classificação"]:
                cell.api.Font.Bold = True
            if header in ["Total", "Classificação"]:
                cell.api.HorizontalAlignment = HAlign.xlHAlignCenter

    wb.app.api.ActiveWindow.DisplayGridlines = False

    # ---- Atualização das Formas (mesma sessão) ----
    ws2 = ws_performance
    retangulos = [
        "Rounded Rectangle 7","Rounded Rectangle 10","Rounded Rectangle 11",
        "Rounded Rectangle 12","Rounded Rectangle 13","Rounded Rectangle 14",
        "Rounded Rectangle 15","Rounded Rectangle 16","Rounded Rectangle 17",
        "Rounded Rectangle 18","Rounded Rectangle 19"
    ]

    cor_fundo_baixa = hex_to_bgr("#FFBDBD")
    cor_fonte_baixa = hex_to_bgr("#FF0000")
    cor_fundo_alta  = hex_to_bgr("#D9F2D0")
    cor_fonte_alta  = hex_to_bgr("#275317")

    for nome in retangulos:
        try:
            shape = ws2.shapes[nome]
            texto = shape.text
            if isinstance(texto, str) and texto.endswith("%"):
                pct = float(texto.replace("%", "").replace(",", "."))
                if pct < 91:
                    shape.api.Fill.ForeColor.RGB = cor_fundo_baixa
                    shape.api.TextFrame2.TextRange.Font.Fill.ForeColor.RGB = cor_fonte_baixa
                else:
                    shape.api.Fill.ForeColor.RGB = cor_fundo_alta
                    shape.api.TextFrame2.TextRange.Font.Fill.ForeColor.RGB = cor_fonte_alta
        except Exception as e:
            print(f"Erro ao processar '{nome}': {e}")

    # >>> Salva uma CÓPIA com as alterações (ainda não mexe no arquivo final)
    tmp_copy_path = save_copy_of_wb(wb)
    print(f"[debug] Cópia temporária salva em: {tmp_copy_path}")

finally:
    # Fecha Excel para liberar qualquer lock antes da troca do arquivo final
    try:
        wb.close()
    except:
        pass
    app.display_alerts = True
    app.screen_updating = True
    app.quit()

# >>> Agora, com Excel fechado, faz a troca com tentativas/backoff no MESMO diretório do destino
if tmp_copy_path and os.path.exists(tmp_copy_path):
    try:
        atomic_replace_with_retries(tmp_copy_path, caminho_dashboard, retries=30, delay=0.25)
        print("✅ Relatório e formas atualizados com sucesso!")
    finally:
        if os.path.exists(tmp_copy_path):
            try:
                os.remove(tmp_copy_path)
            except:
                pass
else:
    raise RuntimeError("Falha ao gerar cópia temporária do dashboard.")
