# -*- coding: utf-8 -*-
# ========= IMPORTS =========
import os
import time
import shutil
import tempfile
import pandas as pd
import xlwings as xw
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter
from datetime import datetime, date as dt_date, time as dt_time, timedelta
from xlwings.constants import HAlign
from uuid import uuid4

# ========= FECHA QUALQUER EXCEL ABERTO =========
os.system("taskkill /f /im excel.exe 2>nul")

# ========= DATA E ARQUIVOS =========
# Defina aqui o INTERVALO de análise (início e fim, inclusive)
data_inicio = datetime.strptime("1/09/2025", "%d/%m/%Y").date()
data_fim    = datetime.strptime("12/09/2025", "%d/%m/%Y").date()

# Pasta base
base_dir = r"F:\BACKOFFICE - CONTACT CENTER\Relatorios Extraidos Automacao"

# Nome do arquivo de entrada (apenas o nome ou com caminho absoluto)
# Ex.: "semanal.xlsx" ou "1009.xlsx"
nome_arquivo = "1209.xlsx"

# Caminhos
caminho_arquivo_original = fr"{base_dir}\{nome_arquivo}" if not os.path.isabs(nome_arquivo) else nome_arquivo
nome_sem_ext = os.path.splitext(os.path.basename(nome_arquivo))[0]
caminho_formatado = fr"{base_dir}\{nome_sem_ext}_Formatado.xlsx"
caminho_dashboard = fr"{base_dir}\Dashboard.xlsx"  # confirmado
caminho_backup = fr"{base_dir}\Dashboard_Template.xlsx"

# ========= BACKUP DO DASHBOARD =========
if os.path.exists(caminho_dashboard):
    shutil.copy(caminho_dashboard, caminho_backup)

# ========= FORMATAR PLANILHA BASE =========
if not os.path.exists(caminho_arquivo_original):
    raise FileNotFoundError(f"Arquivo não encontrado: {caminho_arquivo_original}")

# Salva a planilha original como "Base de Dados"
pd.read_excel(caminho_arquivo_original, dtype=str).to_excel(
    caminho_formatado, index=False, sheet_name="Base de Dados"
)

# ========= FUNÇÕES AUXILIARES =========
def tempo_personalizado(valor):
    """Converte 'HH:MM' ou 'HH:MM:SS' para timedelta; caso contrário, NaT."""
    try:
        partes = str(valor).strip().split(":")
        if len(partes) == 2:
            return pd.to_timedelta(f"{int(partes[0])}:{int(partes[1])}:00")
        elif len(partes) == 3:
            return pd.to_timedelta(valor)
        else:
            return pd.NaT
    except (ValueError, AttributeError):
        return pd.NaT

def classificar_q(c):
    try:
        p = float(str(c).replace('%', '').replace(',', '.'))
        if p >= 100:
            return "Q1"
        elif p >= 95:
            return "Q2"
        elif p >= 90:
            return "Q3"
        else:
            return "Q4"
    except:
        return "-"

def gerar_resumo_com_media(df_base, titulo):
    """
    Gera um pivot: Período x Usuário Backoffice x Hora (08..18), com Total, Conversão e Classificação.
    Se o df estiver vazio, retorna um esqueleto de tabela.
    """
    horas = list(range(8, 19))
    if df_base.empty:
        cols = ["Dia", "Período", "Usuário Backoffice"] + horas + ["Total", "Conversão", "Classificação"]
        return pd.DataFrame(columns=cols)

    tabela = pd.pivot_table(
        df_base, index=["Período", "Usuário Backoffice"], columns="Hora",
        values="Nova Coluna", aggfunc="count", fill_value=0
    ).reset_index()

    # Garante colunas de todas as horas 8..18
    for h in horas:
        if h not in tabela.columns:
            tabela[h] = 0

    # Total por linha
    horas_cols = [h for h in horas]
    tabela["Total"] = tabela[horas_cols].sum(axis=1)

    # Média por Período
    medias = tabela.groupby("Período")["Total"].mean().to_dict()

    # Conversão e classificação
    def conv_pct(row):
        m = medias.get(row["Período"])
        if m and m != 0:
            return f"{round((row['Total'] / m) * 100):.0f}%"
        return "-"

    tabela["Conversão"] = tabela.apply(conv_pct, axis=1)
    tabela["Classificação"] = tabela["Conversão"].apply(classificar_q)

    # Ordena colunas e insere título do período
    tabela = tabela[["Período", "Usuário Backoffice"] + horas_cols + ["Total", "Conversão", "Classificação"]]
    tabela.insert(0, "Dia", titulo)

    # Média final por período
    media_final = (
        tabela.groupby("Período").mean(numeric_only=True).round(1).reset_index().drop_duplicates(subset=["Período"])
    )
    media_final.insert(0, "Dia", f"Média - {titulo}")
    media_final["Usuário Backoffice"] = "-"
    media_final["Conversão"] = "-"
    media_final["Classificação"] = "-"
    media_final = media_final.groupby("Período").first().reset_index()

    # Linha em branco
    linha_vazia = pd.DataFrame([["" for _ in tabela.columns]], columns=tabela.columns)

    return pd.concat([tabela, linha_vazia, media_final], ignore_index=True)

def hex_to_bgr(hex_color):
    """Converte '#RRGGBB' para inteiro BGR (Excel COM)."""
    hex_color = hex_color.lstrip('#')
    r = int(hex_color[0:2], 16)
    g = int(hex_color[2:4], 16)
    b = int(hex_color[4:6], 16)
    return r + (g << 8) + (b << 16)

def save_copy_of_wb(wb):
    r"""Gera uma cópia do workbook aberto (com as alterações) em um arquivo temporário (C:\Temp)."""
    tmp = os.path.join(tempfile.gettempdir(), f"_tmp_{uuid4().hex}.xlsx")
    wb.api.SaveCopyAs(tmp)
    return tmp

def atomic_replace_with_retries(src_tmp, dst_final, retries=30, delay=0.25):
    """
    Troca o arquivo final pelo temporário com tentativas e backoff.
    Evita WinError 17 (discos diferentes) copiando primeiro para um
    temporário no MESMO DIRETÓRIO do destino e então faz os.replace.
    """
    dst_dir = os.path.dirname(dst_final)
    tmp_local = os.path.join(dst_dir, f"._swap_{uuid4().hex}.xlsx")
    last_err = None

    for i in range(retries):
        try:
            # Copia para o mesmo drive/pasta do destino
            if os.path.exists(tmp_local):
                try:
                    os.remove(tmp_local)
                except:
                    pass
            shutil.copyfile(src_tmp, tmp_local)

            # Substitui de forma atômica no mesmo volume
            os.replace(tmp_local, dst_final)

            # Limpa o src_tmp (C:\Temp)
            try:
                if os.path.exists(src_tmp):
                    os.remove(src_tmp)
            except:
                pass

            return  # sucesso
        except (PermissionError, OSError) as e:
            last_err = e
            # tenta limpar tmp_local para próxima tentativa
            try:
                if os.path.exists(tmp_local):
                    os.remove(tmp_local)
            except:
                pass
            time.sleep(delay * (i + 1))  # backoff progressivo

    # esgotou tentativas
    raise last_err

def force_freeze_panes(ws, rows=1, cols=0, cell=None):
    """
    Congela 'rows' linhas e 'cols' colunas na planilha ws.
    Padrão: rows=1, cols=0 -> 1ª linha (A2). Para 1ª linha + 1ª coluna: rows=1, cols=1 (B2).
    """
    app = ws.book.app
    was_visible = app.visible
    app.visible = True  # garante janela ativa

    try:
        ws.api.Activate()
        win = app.api.ActiveWindow

        # Desprotege se necessário
        try:
            if bool(ws.api.ProtectContents):
                ws.api.Unprotect()
        except Exception:
            pass

        # Limpa estado e força Modo Normal
        win.View = 1
        win.FreezePanes = False
        win.SplitRow = 0
        win.SplitColumn = 0

        # Célula âncora
        if cell is None:
            r = 1 + max(rows, 0)
            c = 1 + max(cols, 0)
            cell = ws.range((r, c)).get_address(row_absolute=False, column_absolute=False)
        ws.api.Range(cell).Select()

        win.SplitRow = rows if rows > 0 else 0
        win.SplitColumn = cols if cols > 0 else 0
        win.FreezePanes = (rows > 0 or cols > 0)

    except Exception as e1:
        # Fallback usando a primeira janela do workbook
        try:
            wnd2 = ws.api.Parent.Windows(1)
            wnd2.View = 1
            wnd2.FreezePanes = False
            wnd2.SplitRow = 0
            wnd2.SplitColumn = 0
            ws.api.Range(cell).Select()
            wnd2.SplitRow = rows if rows > 0 else 0
            wnd2.SplitColumn = cols if cols > 0 else 0
            wnd2.FreezePanes = (rows > 0 or cols > 0)
        except Exception as e2:
            raise RuntimeError(f"Falha ao configurar FreezePanes: {e1} | fallback: {e2}")
    finally:
        app.visible = was_visible

# ========= INSERE "NOVA COLUNA" (HORA) =========
wb_aux = load_workbook(caminho_formatado)
ws_aux = wb_aux["Base de Dados"]
df_temp = pd.read_excel(caminho_formatado, sheet_name="Base de Dados", dtype=str)

coluna_Hr_Associacao = "Hr. Associação Comercial"
coluna_Tempo_Associacao = "Tempo de Associação"
coluna_Hr_idx = df_temp.columns.get_loc(coluna_Hr_Associacao) + 1
coluna_Tempo_idx = df_temp.columns.get_loc(coluna_Tempo_Associacao) + 1

ws_aux.insert_cols(coluna_Tempo_idx)
ws_aux[f"{get_column_letter(coluna_Tempo_idx)}1"] = "Nova Coluna"

for row in range(2, ws_aux.max_row + 1):
    valor_hora = ws_aux.cell(row=row, column=coluna_Hr_idx).value
    try:
        hora = datetime.strptime(str(valor_hora).strip(), "%H:%M").hour
        ws_aux.cell(row=row, column=coluna_Tempo_idx).value = hora
    except (ValueError, TypeError):
        continue

wb_aux.save(caminho_formatado)

# ========= LEITURA / TRATAMENTO DE DADOS =========
df = pd.read_excel(caminho_formatado, sheet_name="Base de Dados", dtype=str)

df["Dt. Associação Comercial"] = pd.to_datetime(df["Dt. Associação Comercial"], dayfirst=True, errors="coerce")
df["Hr. Associação Comercial"] = pd.to_datetime(
    df["Hr. Associação Comercial"], format="%H:%M", errors="coerce"
).dt.time
df["Dt. Pré-agendamento"] = pd.to_datetime(df["Dt. Pré-agendamento"], dayfirst=True, errors="coerce")
df["Hr. Pré-agendamento"] = pd.to_datetime(df["Hr. Pré-agendamento"], format="%H:%M", errors="coerce")
df["Nova Coluna"] = pd.to_numeric(df["Nova Coluna"], errors="coerce")
df["Tempo de Associação Convertido"] = df["Tempo de Associação"].apply(tempo_personalizado)
df["Dt. Visita Real"] = pd.to_datetime(df["Dt. Visita Real"], dayfirst=True, errors="coerce")
df["Hr. Visita"] = pd.to_datetime(df["Hr. Visita"], format="%H:%M", errors="coerce").dt.time

df = df.dropna(subset=[
    "Dt. Associação Comercial", "Nova Coluna", "Tempo de Associação Convertido",
    "Dt. Pré-agendamento", "Hr. Pré-agendamento"
])

df["Hora"] = df["Nova Coluna"].astype(int)
df["Data"] = df["Dt. Associação Comercial"].dt.date
df["Minutos Associacao"] = df["Tempo de Associação Convertido"].dt.total_seconds() / 60
df["Hora Pre"] = df["Hr. Pré-agendamento"].dt.hour

# ========= APLICA INTERVALO =========
mask_periodo = (df["Data"] >= data_inicio) & (df["Data"] <= data_fim)
df_periodo = df.loc[mask_periodo].copy()

# ========= CÁLCULOS (PERÍODO) =========
horas = list(range(8, 19))

# 1) Contagens por hora no período
realizado = [df_periodo[df_periodo["Hora"] == h].shape[0] for h in horas]
menos_1h = [df_periodo[(df_periodo["Hora"] == h) & (df_periodo["Minutos Associacao"] < 60)].shape[0] for h in horas]

# 2) Perda real no período (pré no mesmo dia, 08:00–18:30, >=60min), por hora de pré
df_real_periodo = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date == df["Data"]) &
    (df["Hr. Pré-agendamento"].dt.time >= dt_time(8, 0)) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(18, 30)) &
    (df["Minutos Associacao"] >= 60)
]
perda_real = [df_real_periodo[df_real_periodo["Hora Pre"] == h].shape[0] for h in horas]

# 3) Total do período (pré do mesmo dia, 06:00–23:00, >=60min)
df_total_periodo = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date == df["Data"]) &
    (df["Hr. Pré-agendamento"].dt.time >= dt_time(6, 0)) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(23, 0)) &
    (df["Minutos Associacao"] >= 60)
]

# 4) Indicadores agregados do período
quantidade_10h = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Visita Real"].dt.date == df["Data"]) &
    (df["Hr. Visita"] >= dt_time(10, 0)) & (df["Hr. Visita"] < dt_time(11, 0))
].shape[0]

quantidade_0830 = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date < df["Data"]) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(8, 30))
].shape[0]

quantidade_acumulados = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date < df["Data"])
].shape[0]

quantidade_mesmo_dia_0830 = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date == df["Data"]) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(8, 30))
].shape[0]

total_acumulado_completo = quantidade_acumulados + quantidade_mesmo_dia_0830

total_acumulado_ate_0730 = df[
    (df["Data"] >= data_inicio) & (df["Data"] <= data_fim) &
    (df["Dt. Pré-agendamento"].dt.date == df["Data"]) &
    (df["Hr. Pré-agendamento"].dt.time <= dt_time(7, 30))
].shape[0] + quantidade_acumulados

# ========= USUÁRIOS / PERÍODO =========
usuarios_desejados = [
    "CAROLINE APARECIDA DA SILVA BARROZO", "DAVI GUERRA VAINE SILVA", "DAYSE MIRANDA DOS SANTOS",
    "Diana Aparecida Barbosa Cesar", "DIANNE ALVES SILVA GONCALVES", "ISABELLY FERREIRA COSTA",
    "JOAO VICTOR GONCALVES TAVARES DA SILVA", "JULIA GOMES SILVA", "LARYSSA MIGORANÇA KLEIN DA SILVA",
    "MARIA DO ESPIRITO SANTO DA COSTA SILVA", "SARA ARAUJO SOUZA", "WESLLEY MORAES DE AMORIM",
    "RAFAELLA DIAS OLIVEIRA"
]
filtro_usuarios = df[df["Usuário Backoffice"].isin(usuarios_desejados)].copy()
filtro_usuarios["Período"] = filtro_usuarios["Usuário Backoffice"].apply(
    lambda x: "Manhã" if x in [
        "CAROLINE APARECIDA DA SILVA BARROZO", "DAYSE MIRANDA DOS SANTOS", "RAFAELLA DIAS OLIVEIRA",
        "Diana Aparecida Barbosa Cesar", "DIANNE ALVES SILVA GONCALVES", "ISABELLY FERREIRA COSTA",
        "JULIA GOMES SILVA", "MARIA DO ESPIRITO SANTO DA COSTA SILVA", "SARA ARAUJO SOUZA"
    ] else "Tarde"
)

# ========= EXCEL (SESSÃO ÚNICA) =========
app = xw.App(visible=False)
app.display_alerts = False
app.screen_updating = False

tmp_copy_path = None  # caminho da cópia do workbook

try:
    wb = app.books.open(caminho_dashboard, update_links=False, read_only=False)
    ws_base = wb.sheets["Base de Dados"]
    ws_performance = wb.sheets["Performance BackOffice"]

    # ---- Base de Dados (agregados do período) ----
    for i, h in enumerate(horas):
        linha = i + 2
        ws_base[f"A{linha}"].value = f"{h:02d}:00"
        ws_base[f"B{linha}"].value = realizado[i]
        ws_base[f"C{linha}"].value = menos_1h[i]
        ws_base[f"D{linha}"].value = perda_real[i]

    ws_base["A15"].value = sum(menos_1h)
    ws_base["B15"].value = sum(realizado)
    ws_base["A18"].value = sum(perda_real)
    ws_base["B18"].value = df_total_periodo.shape[0]
    ws_base["B21"].value = quantidade_acumulados
    ws_base["B22"].value = total_acumulado_completo
    ws_base["B23"].value = total_acumulado_ate_0730

    # ---- Performance (usa a data final do período) ----
    ws_performance.range("R2").value = data_fim
    ws_performance.range("R2").number_format = "dd/mm/yyyy"
    ws_performance.range("M2").value = quantidade_10h
    ws_performance.range("M3").value = quantidade_0830
    ws_performance.range("L2").value = total_acumulado_completo

    # ---- Resumo por Hora (período) ----
    resumo_sheet_name = f"Resumo {data_inicio.strftime('%d.%m')}–{data_fim.strftime('%d.%m')}"
    if resumo_sheet_name in [s.name for s in wb.sheets]:
        wb.sheets[resumo_sheet_name].delete()
    ws_resumo = wb.sheets.add(name=resumo_sheet_name, after=ws_performance)

    resumo_df = filtro_usuarios[(filtro_usuarios["Data"] >= data_inicio) & (filtro_usuarios["Data"] <= data_fim)]
    titulo_resumo = f"Período {data_inicio.strftime('%d/%m/%Y')} – {data_fim.strftime('%d/%m/%Y')}"
    resumo = gerar_resumo_com_media(resumo_df, titulo_resumo)
    ws_resumo.range("A1").value = [resumo.columns.tolist()] + resumo.values.tolist()

    # Cabeçalho
    last_row = ws_resumo.range("A1").end("down").row
    last_col = ws_resumo.range("A1").end("right").column
    for col in range(1, last_col + 1):
        cell = ws_resumo.range((1, col))
        cell.color = "#002060"
        cell.font.color = "#FFFFFF"

    # Congelar 1ª linha (robusto)
    force_freeze_panes(ws_resumo, rows=1, cols=0)  # para 1ª linha+coluna: rows=1, cols=1

    # Largura da coluna "Usuário Backoffice"
    for col in range(1, last_col + 1):
        header_val = str(ws_resumo.range((1, col)).value).strip()
        if header_val == "Usuário Backoffice":
            ws_resumo.range((1, col)).column_width = 30
            break

    # Cores e formatação (parse % corrigido)
    for row in range(2, last_row + 1):
        valores_linha = [ws_resumo.range((row, col)).value for col in range(1, last_col + 1)]
        if all(v in [None, ""] for v in valores_linha):
            continue

        for col in range(1, last_col + 1):
            cell = ws_resumo.range((row, col))
            header = str(ws_resumo.range((1, col)).value).strip()

            if header == "Conversão":
                valor = cell.value
                if isinstance(valor, (int, float)):
                    valor = f"{valor:.0f}%"
                else:
                    valor = str(valor)
                try:
                    if valor.endswith("%"):
                        pct = float(valor.replace("%", "").replace(",", "."))
                        if pct >= 100:
                            cell.api.Interior.Color = 0x00FF00
                        elif pct >= 95:
                            cell.api.Interior.Color = 0xE2EFDA
                        elif pct >= 91:
                            cell.api.Interior.Color = 0xFFF2CC
                        else:
                            cell.api.Interior.Color = 0xF8CBAD
                except:
                    pass

            if header in ["Usuário Backoffice", "Total", "Classificação"]:
                cell.api.Font.Bold = True
            if header in ["Total", "Classificação"]:
                cell.api.HorizontalAlignment = HAlign.xlHAlignCenter

    wb.app.api.ActiveWindow.DisplayGridlines = False

    # ---- Atualização das Formas (mesma sessão) ----
    ws2 = ws_performance
    retangulos = [
        "Rounded Rectangle 7","Rounded Rectangle 10","Rounded Rectangle 11",
        "Rounded Rectangle 12","Rounded Rectangle 13","Rounded Rectangle 14",
        "Rounded Rectangle 15","Rounded Rectangle 16","Rounded Rectangle 17",
        "Rounded Rectangle 18","Rounded Rectangle 19"
    ]

    cor_fundo_baixa = hex_to_bgr("#FFBDBD")
    cor_fonte_baixa = hex_to_bgr("#FF0000")
    cor_fundo_alta  = hex_to_bgr("#D9F2D0")
    cor_fonte_alta  = hex_to_bgr("#275317")

    for nome in retangulos:
        try:
            shape = ws2.shapes[nome]
            texto = shape.text
            if isinstance(texto, str) and texto.endswith("%"):
                pct = float(texto.replace("%", "").replace(",", "."))
                if pct < 91:
                    shape.api.Fill.ForeColor.RGB = cor_fundo_baixa
                    shape.api.TextFrame2.TextRange.Font.Fill.ForeColor.RGB = cor_fonte_baixa
                else:
                    shape.api.Fill.ForeColor.RGB = cor_fundo_alta
                    shape.api.TextFrame2.TextRange.Font.Fill.ForeColor.RGB = cor_fonte_alta
        except Exception as e:
            print(f"Erro ao processar '{nome}': {e}")

    # >>> Salva uma CÓPIA com as alterações (ainda não mexe no arquivo final)
    tmp_copy_path = save_copy_of_wb(wb)
    print(f"[debug] Cópia temporária salva em: {tmp_copy_path}")

finally:
    # Fecha Excel para liberar qualquer lock antes da troca do arquivo final
    try:
        wb.close()
    except:
        pass
    app.display_alerts = True
    app.screen_updating = True
    app.quit()

# >>> Agora, com Excel fechado, faz a troca com tentativas/backoff no MESMO diretório do destino
if tmp_copy_path and os.path.exists(tmp_copy_path):
    try:
        atomic_replace_with_retries(tmp_copy_path, caminho_dashboard, retries=30, delay=0.25)
        print("✅ Relatório e formas atualizados com sucesso!")
    finally:
        if os.path.exists(tmp_copy_path):
            try:
                os.remove(tmp_copy_path)
            except:
                pass
else:
    raise RuntimeError("Falha ao gerar cópia temporária do dashboard.")
